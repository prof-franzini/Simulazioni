<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Moto parabolico ‚Äî Campo montano (Pan & Zoom + Joystick)</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
<style>
  :root{
    --bg:#f3f7fb; --card:#ffffff; --muted:#667085; --accent:#0b84ff; --accent2:#ff8c42;
    --ctl:#eef2f6; --ctl-border:#d9dee6; --btn:#2d3748;
    --skyTop:#9fd3ff; --skyMid:#bfe7ff; --skyBot:#e9f6ff;
    --mountainFar:#7fa3b8; --mountainNear:#5f8b9e; --grass:#7cc36b; --soil:#5b7a4f; --trail:#ffb703;
  }
  body{margin:0;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);color:#102a43;}
  .wrap{max-width:1100px;margin:20px auto;padding:16px;}
  h1{margin:0 0 6px;color:var(--accent);font-size:20px;}
  .sub{color:var(--muted);margin-bottom:12px;}
  #holder{width:100%;background:var(--card);border-radius:14px;box-shadow:0 10px 24px rgba(16,42,67,.08);overflow:hidden;}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;padding:12px;}
  .ctrl{background:var(--ctl);border:1px solid var(--ctl-border);padding:10px;border-radius:10px;display:flex;gap:10px;align-items:center;}
  .label{font-weight:700;margin-right:6px;}
  input[type="range"]{width:220px;accent-color:var(--accent);}
  .btn{background:var(--btn);color:#fff;border:0;padding:10px 14px;border-radius:10px;cursor:pointer;font-weight:800;}
  .btn.alt{background:var(--accent2);color:#120800;}
  .stat{background:#fff;border:1px solid var(--ctl-border);border-radius:999px;padding:6px 10px;font-weight:700;}
  .small{font-size:13px;color:#667085;}
  @media (max-width:820px){.controls{flex-direction:column;align-items:stretch}input[type="range"]{width:100%}}
</style>
</head>
<body>
<div class="wrap">
  <h1>Moto parabolico ‚Äî Campo montano</h1>
  <div class="sub">Sinistra: panoramica con pan & zoom ¬∑ Destra: telecamera che segue il proiettile</div>
  <div id="holder"></div>

  <div class="controls">
    <div class="ctrl">
      <span class="label">Potenza</span>
      <input id="power" type="range" min="10" max="120" step="1" value="60" />
      <span id="label-power" class="small">60 m/s</span>
    </div>
    <div class="ctrl">
      <span class="label">Angolo</span>
      <input id="angle" type="range" min="10" max="80" step="1" value="45" />
      <span id="label-angle" class="small">45¬∞</span>
    </div>
    <div class="ctrl">
      <button id="btn-fire" class="btn">Spara</button>
      <button id="btn-pause" class="btn">Pausa</button>
      <button id="btn-reset" class="btn alt">Reset</button>
    </div>
    <div class="ctrl">
      <button id="zoom-out" class="btn">Zoom ‚àí</button>
      <button id="zoom-in"  class="btn">Zoom +</button>
      <button id="zoom-reset" class="btn">Centra</button>
      <span class="small">Pan: ‚Üê ‚Üë ‚Üì ‚Üí</span>
    </div>

    <!-- üéÆ Joystick -->
    <div class="ctrl" style="justify-content:center;flex-direction:column;align-items:center">
      <div id="joystick" style="
        position:relative;
        width:100px;
        height:100px;
        background:#eef2f6;
        border:2px solid #ccd5e0;
        border-radius:50%;
        touch-action:none;">
        <div id="stick" style="
          position:absolute;
          left:50%;
          top:50%;
          width:36px;
          height:36px;
          background:#2d3748;
          border-radius:50%;
          transform:translate(-50%,-50%);
          transition:transform 0.05s linear;">
        </div>
      </div>
      <span class="small" style="margin-top:6px">Trascina per spostare la vista</span>
    </div>

    <div class="ctrl" style="gap:16px">
      <span class="stat">Tempo di volo: <span id="tflight">0.00</span> s</span>
      <span class="stat">Altezza massima: <span id="hmax">0</span> m</span>
      <span class="stat">Gittata: <span id="range">0</span> m</span>
    </div>
  </div>
</div>

<script>
/* ======= Stato e costanti ======= */
const holder=document.getElementById('holder');
const inputPower=document.getElementById('power');
const inputAngle=document.getElementById('angle');
const labelPower=document.getElementById('label-power');
const labelAngle=document.getElementById('label-angle');
const btnFire=document.getElementById('btn-fire');
const btnPause=document.getElementById('btn-pause');
const btnReset=document.getElementById('btn-reset');
const btnZoomIn=document.getElementById('zoom-in');
const btnZoomOut=document.getElementById('zoom-out');
const btnZoomReset=document.getElementById('zoom-reset');
const tflightEl=document.getElementById('tflight');
const hmaxEl=document.getElementById('hmax');
const rangeEl=document.getElementById('range');

let W=1100,H=540;
let leftPanel={},rightPanel={};
const g=9.81;
let ppmLeft=24,ppmRight=32;
let paused=false,lastMs=null;
let proj=null,currentTrail=[],shots=[],maxHeightSoFar=0;
let hillsFar=[],hillsNear=[],groundY=0;
let camX=0,camY=5,CAM_LERP=0.12;

// Camera (sinistra)
let leftZoom=0.3;
let leftPanX=0,leftPanY=0;
const ZOOM_STEP=1.15;
const PAN_STEP_M=5;

// Limiti di pan
const PAN_LIMIT_X_MIN = -100;
const PAN_LIMIT_X_MAX = 1000;
const PAN_LIMIT_Y_MIN = -50;
const PAN_LIMIT_Y_MAX = 300;

/* ======= Utilit√† ======= */
function deg2rad(d){return d*Math.PI/180;}
function clamp(v,a,b){return Math.max(a,Math.min(b,v));}
function lerp(a,b,t){return a+(b-a)*t;}
function getCSS(v){return getComputedStyle(document.documentElement).getPropertyValue(v);}
function clampPan(){
  leftPanX = clamp(leftPanX, PAN_LIMIT_X_MIN, PAN_LIMIT_X_MAX);
  leftPanY = clamp(leftPanY, PAN_LIMIT_Y_MIN, PAN_LIMIT_Y_MAX);
}

/* ======= Fisica ======= */
function theory(v0,theta){
  const tflight=2*v0*Math.sin(theta)/g;
  const Hmax=(v0*v0*Math.sin(theta)**2)/(2*g);
  const R=(v0*v0*Math.sin(2*theta))/g;
  return {tflight,Hmax,R};
}

/* ======= Layout pannelli e scale ======= */
function layoutPanels(){
  const gap=12,pad=12;
  const usableW=holder.getBoundingClientRect().width||W;
  W=Math.max(1300,Math.min(1200,Math.floor(usableW)));
  H=Math.floor(W*0.48);
  const panelW=Math.floor((W-pad*2-gap)/2);
  const panelH=H-pad*2;
  leftPanel={x:pad,y:pad,w:panelW,h:panelH};
  rightPanel={x:pad+panelW+gap,y:pad,w:panelW,h:panelH};

  let maxRange=60;
  for(const s of shots){if(s._R)maxRange=Math.max(maxRange,s._R);}
  if(proj&&proj._R)maxRange=Math.max(maxRange,proj._R);
  const targetRange=Math.max(40,maxRange)*1.3;
  const basePPM=clamp(Math.floor(leftPanel.w/targetRange),4,28);
  ppmLeft=clamp(Math.floor(basePPM*leftZoom),1,240);
  ppmRight=clamp(Math.floor(rightPanel.w/50),18,42);
}

/* ======= Clip helper ======= */
function beginClip(p,pan){const c=p.drawingContext;c.save();c.beginPath();c.roundRect(pan.x,pan.y,pan.w,pan.h,10);c.clip();}
function endClip(p){p.drawingContext.restore();}

/* ======= Mappe coordinate ======= */
function worldToScreenLeft(xm,ym){
  const marginL=40;
  const pyGround=leftPanel.y+Math.round(leftPanel.h*0.7);
  const px=leftPanel.x+marginL+Math.round((xm-leftPanX)*ppmLeft);
  const py=pyGround-Math.round((ym-groundY)*ppmLeft);
  return {x:px,y:py,ground:pyGround};
}
function worldToScreenRight(xm,ym){
  const cx=rightPanel.x+rightPanel.w/2;
  const cy=rightPanel.y+rightPanel.h*0.65;
  const px=cx+Math.round((xm-camX)*ppmRight);
  const py=cy-Math.round((ym-camY)*ppmRight);
  return {x:px,y:py};
}

/* ======= Scenario ======= */
function generateHills(){
  hillsFar=[];hillsNear=[];
  const Wm=1800,spacing=12;
  for(let x=-400;x<=Wm;x+=spacing){
    const y=40+8*Math.sin(x*0.03)+4*Math.sin(x*0.11+1.2)+3*Math.sin(x*0.05-0.7)+2*Math.sin(x*0.2+1.2);
    hillsFar.push({x,y});
  }
  for(let x=-400;x<=Wm;x+=spacing){
    const y=25
      +12*Math.sin(x*0.025+0.4)
      +6*Math.sin(x*0.09-1.1)
      +3*Math.sin(x*0.18+0.9)
      +2*Math.sin(x*0.33-0.7)
      +1.5*Math.sin(x*0.5+2.2);
    hillsNear.push({x,y});
  }
}

/* ======= Dinamica ======= */
function newProjectile(v0,theta){
    maxHeightSoFar = 0;  // reset altezza massima ogni nuovo lancio

  const vx=v0*Math.cos(theta), vy=v0*Math.sin(theta);
  const th=theory(v0,theta);
  proj={x:0,y:0,vx,vy,t:0,alive:true,_R:th.R,_T:th.tflight,_H:th.Hmax};
  currentTrail=[{x:0,y:0}];
  tflightEl.textContent=th.tflight.toFixed(2);
  hmaxEl.textContent=Math.round(th.Hmax);
  rangeEl.textContent=Math.round(th.R);
;
}
function stepPhysics(dt){
  if(!proj||!proj.alive)return;
  proj.t+=dt; proj.vy-=g*dt; proj.x+=proj.vx*dt; proj.y+=proj.vy*dt;
// Aggiorna valori in tempo reale
tflightEl.textContent = proj.t.toFixed(2);
rangeEl.textContent = Math.round(proj.x);

// altezza istantanea sopra il suolo
const currentHeight = proj.y - groundY;
if (currentHeight > maxHeightSoFar) {
  maxHeightSoFar = currentHeight;
  hmaxEl.textContent = Math.round(maxHeightSoFar);
}



  if(proj.y<=groundY){
  proj.y=groundY;
  proj.alive=false;
  shots.push(Object.assign(currentTrail.slice(),{_R:proj._R}));
  // Fissa i valori finali quando tocca terra
  tflightEl.textContent = proj._T.toFixed(2);
  hmaxEl.textContent = Math.round(proj._H);
  rangeEl.textContent = Math.round(proj._R);
}

  else currentTrail.push({x:proj.x,y:proj.y});
}

/* ======= Disegno ======= */
function drawSkyGrad(p,X,Y,Wp,Hp){
  const t1=p.color(getCSS('--skyTop')),t2=p.color(getCSS('--skyMid')),t3=p.color(getCSS('--skyBot'));
  for(let i=0;i<Hp;i++){const t=i/(Hp-1);const c=t<.5?p.lerpColor(t1,t2,t*2):p.lerpColor(t2,t3,(t-.5)*2);p.stroke(c);p.line(X,Y+i,X+Wp,Y+i);}
}
function drawGround(p,py,X,Wp){p.noStroke();p.fill(getCSS('--grass'));p.rect(X,py,Wp,999);p.fill(getCSS('--soil'));p.rect(X,py+40,Wp,999);}
function drawProjectile(p,px,py){p.noStroke();p.fill(255,165,0,200);p.circle(px,py,14);p.fill(255,200,80,120);p.circle(px,py,26);}

/* ======= Pannello SINISTRO ======= */
function drawLeft(p){
  const X=leftPanel.x,Y=leftPanel.y,Wp=leftPanel.w,Hp=leftPanel.h;
  p.push();p.noStroke();p.fill('#fff');p.rect(X,Y,Wp,Hp,10);
  beginClip(p,leftPanel);

  p.push();
  p.translate(0, leftPanY * ppmLeft);

  drawSkyGrad(p,X,Y-1200,Wp,Hp+2400);

  p.fill(getCSS('--mountainFar'));p.beginShape();p.vertex(X,Y+Hp);
  for(const h of hillsFar){const s=worldToScreenLeft(h.x,h.y+8);p.vertex(s.x,s.y);}p.vertex(X+Wp,Y+Hp);p.endShape();

  p.fill(getCSS('--mountainNear'));p.beginShape();p.vertex(X,Y+Hp);
  for(const h of hillsNear){const s=worldToScreenLeft(h.x,h.y+4);p.vertex(s.x,s.y);}p.vertex(X+Wp,Y+Hp);p.endShape();

  const gLine=worldToScreenLeft(0,groundY).ground;
  drawGround(p,gLine,X,Wp);
  drawCannonPanorama(p,gLine);

  for(const poly of shots){p.noFill();p.stroke(getCSS('--trail'));p.strokeWeight(2.2);p.beginShape();
    for(const pt of poly){const s=worldToScreenLeft(pt.x,pt.y);p.vertex(s.x,s.y);}p.endShape();}
  if(currentTrail.length){p.noFill();p.stroke('#ff7f11');p.strokeWeight(2.2);p.beginShape();
    for(const pt of currentTrail){const s=worldToScreenLeft(pt.x,pt.y);p.vertex(s.x,s.y);}p.endShape();}
  if(proj){const s=worldToScreenLeft(proj.x,proj.y);drawProjectile(p,s.x,s.y);}

  p.pop();
  endClip(p);
  p.fill('#0b253a');p.noStroke();p.textSize(13);p.text('Panoramica',X+10,Y+18);
  p.pop();
}
function drawCannonPanorama(p,groundLine){
  const base=worldToScreenLeft(0,groundY);
  const ang=parseFloat(inputAngle.value);
  const scale=0.6;
  p.push();
  p.translate(base.x,groundLine);
  p.scale(scale);
  p.noStroke();p.fill(70);
  p.rect(-16,-12,34,20,6);
  p.push();
  p.translate(0,-8);
  p.rotate(-deg2rad(ang));
  p.fill(60);
  p.rect(0,-7,50,14,7);
  p.pop();
  p.pop();
}

/* ======= Pannello DESTRO ======= */
function drawRight(p){
  const X=rightPanel.x,Y=rightPanel.y,Wp=rightPanel.w,Hp=rightPanel.h;
  p.push();p.noStroke();p.fill('#fff');p.rect(X,Y,Wp,Hp,10);
  beginClip(p,rightPanel);

  if(proj){camX=lerp(camX,proj.x+6,CAM_LERP);camY=lerp(camY,Math.max(groundY+4,proj.y),CAM_LERP);}

  drawSkyGrad(p,X,Y,Wp,Hp);

  // Montagne identiche a sinistra
  p.fill(getCSS('--mountainFar'));p.beginShape();p.vertex(X,Y+Hp);
  for(const h of hillsFar){const s=worldToScreenRight(h.x,h.y+8);p.vertex(s.x,s.y);}p.vertex(X+Wp,Y+Hp);p.endShape();

  p.fill(getCSS('--mountainNear'));p.beginShape();p.vertex(X,Y+Hp);
  for(const h of hillsNear){const s=worldToScreenRight(h.x,h.y+4);p.vertex(s.x,s.y);}p.vertex(X+Wp,Y+Hp);p.endShape();

  const gScr=worldToScreenRight(0,groundY);drawGround(p,gScr.y,X,Wp);
  const cannonS=worldToScreenRight(0,groundY);drawCannonFollow(p,cannonS.x,cannonS.y);

  p.noFill();p.stroke(getCSS('--trail'));p.strokeWeight(2.2);
  for(const poly of shots){p.beginShape();for(const pt of poly){const s=worldToScreenRight(pt.x,pt.y);p.vertex(s.x,s.y);}p.endShape();}
  if(currentTrail.length){p.noFill();p.stroke('#ff7f11');p.strokeWeight(2.2);p.beginShape();
    for(const pt of currentTrail){const s=worldToScreenRight(pt.x,pt.y);p.vertex(s.x,s.y);}p.endShape();}
  if(proj){const s=worldToScreenRight(proj.x,proj.y);drawProjectile(p,s.x,s.y);}

  endClip(p);
  p.fill('#0b253a');p.noStroke();p.textSize(13);p.text('Follow-cam',X+10,Y+18);
  p.pop();
}
function drawCannonFollow(p,cx,cy){
  const ang=parseFloat(inputAngle.value);
  p.push();p.translate(cx,cy);p.noStroke();p.fill(70);p.rect(-16,-12,34,20,6);
  p.push();p.translate(0,-8);p.rotate(-deg2rad(ang));p.fill(60);p.rect(0,-7,50,14,7);p.pop();p.pop();
}

/* ======= p5 setup/draw ======= */
new p5(p=>{
  p.setup=()=>{
    const b=holder.getBoundingClientRect();
    const cnv=p.createCanvas(Math.max(720,Math.min(1200,Math.floor(b.width))),540);
    cnv.parent(holder);
    layoutPanels();
    generateHills();
    lastMs=p.millis();
    p.frameRate(60);
  };
  p.windowResized=()=>{layoutPanels();p.resizeCanvas(W,H);};
  p.draw=()=>{
    const now=p.millis();let dt=(now-(lastMs??now))/1000;lastMs=now;dt=Math.min(dt,0.05);
    if(!paused)stepPhysics(dt);
    p.clear(0,0,0,0);
    drawLeft(p);
    drawRight(p);
  };
});

/* ======= UI ======= */
inputPower.oninput=()=>{labelPower.textContent=`${inputPower.value} m/s`;const v0=+inputPower.value;const th=theory(v0,deg2rad(+inputAngle.value));proj&&(proj._R=th.R);layoutPanels();};
inputAngle.oninput=()=>{labelAngle.textContent=`${inputAngle.value}¬∞`;const v0=+inputPower.value;const th=theory(v0,deg2rad(+inputAngle.value));proj&&(proj._R=th.R);layoutPanels();};
btnFire.onclick=()=>{if(proj&&proj.alive)return;const v0=+inputPower.value;newProjectile(v0,deg2rad(+inputAngle.value));layoutPanels();};
btnPause.onclick=()=>{paused=!paused;btnPause.textContent=paused?'Riprendi':'Pausa';};
btnReset.onclick=()=>{proj=null;currentTrail=[];shots.length=0;camX=6;camY=5;tflightEl.textContent=hmaxEl.textContent=rangeEl.textContent='0.00';leftPanX=0;leftPanY=0;leftZoom=0.3;clampPan();layoutPanels();};

/* ======= Zoom ======= */
function applyZoomScale(newZoom){
  newZoom=clamp(newZoom,0.02,5);
  const prevZoom=leftZoom;
  if(newZoom===prevZoom) return;
  const centerX=leftPanel.x+leftPanel.w/2;
  const centerY=leftPanel.y+leftPanel.h/2;
  const marginL=40;
  const pyGround=leftPanel.y+Math.round(leftPanel.h*0.7);
  const worldXc = leftPanX + (centerX - (leftPanel.x + marginL)) / ppmLeft;
  const worldYc = groundY + (pyGround - centerY)/ppmLeft + leftPanY;
  leftZoom=newZoom;
  layoutPanels();
  leftPanX = worldXc - (centerX - (leftPanel.x + marginL)) / ppmLeft;
  leftPanY = worldYc - groundY + (centerY - pyGround) / ppmLeft;
  clampPan();
}
btnZoomIn.onclick = ()=>applyZoomScale(leftZoom*ZOOM_STEP);
btnZoomOut.onclick= ()=>applyZoomScale(leftZoom/ZOOM_STEP);
btnZoomReset.onclick=()=>{leftPanX=0;leftPanY=0;leftZoom=0.3;clampPan();layoutPanels();};

/* ======= Pan frecce ======= */
window.addEventListener('keydown',e=>{
  const s=PAN_STEP_M;
  if(e.key==='ArrowLeft'){leftPanX-=s;clampPan();layoutPanels();e.preventDefault();}
  if(e.key==='ArrowRight'){leftPanX+=s;clampPan();layoutPanels();e.preventDefault();}
  if(e.key==='ArrowUp'){leftPanY+=s;clampPan();layoutPanels();e.preventDefault();}
  if(e.key==='ArrowDown'){leftPanY-=s;clampPan();layoutPanels();e.preventDefault();}
});

/* ======= Joystick PAN ======= */
const joy=document.getElementById('joystick');
const stick=document.getElementById('stick');
let joyActive=false;
joy.addEventListener('pointerdown',e=>{
  joyActive=true;
  joy.setPointerCapture(e.pointerId);
});
joy.addEventListener('pointermove',e=>{
  if(!joyActive)return;
  const rect=joy.getBoundingClientRect();
  const cx=rect.width/2, cy=rect.height/2;
  const dx=e.clientX-rect.left-cx;
  const dy=e.clientY-rect.top-cy;
  const dist=Math.min(Math.sqrt(dx*dx+dy*dy),40);
  const angle=Math.atan2(dy,dx);
  const nx=Math.cos(angle)*dist;
  const ny=Math.sin(angle)*dist;
  stick.style.transform=`translate(${nx}px,${ny}px) translate(-50%,-50%)`;
  leftPanX += nx * 0.05;
  leftPanY -= ny * 0.05;
  clampPan();
  layoutPanels();
});
joy.addEventListener('pointerup',()=>{
  joyActive=false;
  stick.style.transform='translate(-50%,-50%)';
});
joy.addEventListener('pointerleave',()=>{
  joyActive=false;
  stick.style.transform='translate(-50%,-50%)';
});
</script>
</body>
</html>
