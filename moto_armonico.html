<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Moto armonico: proiezione del moto circolare</title>
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
  <style>
    :root {
      --bg: #f7f7f7;
      --card: #ffffff;
      --text: #222;
      --muted: #666;
      --accent: #0072B2;
      --omega: #3BAFDA;
      --phi: #F4B400;
      --control: #eaeaea;
      --ctl-border: #d0d0d0;
    }
    body {
      margin: 0; font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--text); background: var(--bg);
    }
    .wrap {
      max-width: 1100px; margin: 24px auto; padding: 16px;
      background: var(--card); border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,.08);
    }
    h1 { margin: 0 0 8px; font-size: 22px; }
    .sub { color: var(--muted); margin-bottom: 16px; }
    #canvas-holder { width: 100%; border: 1px solid #eee; border-radius: 12px; overflow: hidden; }
    .controls {
      display: grid; grid-template-columns: repeat(12, 1fr); gap: 10px;
      margin-top: 14px; align-items: center;
    }
    .group {
      background: var(--control); border: 1px solid var(--ctl-border);
      border-radius: 10px; padding: 10px;
    }
    .group h3 { margin: 0 0 8px; font-size: 13px; color: var(--muted); text-transform: uppercase; letter-spacing: .04em; }
    .span-12 { grid-column: span 12; }
    .span-6  { grid-column: span 6; }
    .span-4  { grid-column: span 4; }
    .span-3  { grid-column: span 3; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    input[type="range"] {
      width: 100%; accent-color: var(--accent);
    }
    .btn {
      appearance: none; border: 0; padding: 10px 14px; border-radius: 10px; cursor: pointer;
      background: #ccc; transition: transform .05s ease, box-shadow .2s ease;
      font-weight: 600;
      box-shadow: 0 2px 0 rgba(0,0,0,.15);
    }
    .btn:active { transform: translateY(1px); box-shadow: 0 1px 0 rgba(0,0,0,.2); }
    .btn.accent { background: var(--accent); color: #fff; }
    .btn.omega  { background: var(--omega); color: #083042; }
    .btn.phi    { background: var(--phi); color: #5c4300; }
    .label-chip {
      background: #fff; border: 1px solid var(--ctl-border); border-radius: 999px; padding: 6px 10px; font-weight: 600;
    }
    .hint { font-size: 12px; color: var(--muted); }
    @media (max-width: 820px){
      .controls { grid-template-columns: repeat(6, 1fr); }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Moto armonico da moto circolare</h1>
    <div class="sub">Pannello sinistro: cerchio e proiezione su x. • Pannello destro: y(t) = r · f(ωt + φ) con scorrimento.</div>
    <div id="canvas-holder"></div>

    <div class="controls">
      <div class="group span-12">
        <div class="row">
          <button id="btn-toggle" class="btn accent">Funzione: SENO</button>
          <button id="btn-pause" class="btn">Blocca</button>
          <button id="btn-reset" class="btn">Reset</button>
        </div>
      </div>

      <div class="group span-6">
        <h3>Raggio r</h3>
        <div class="row" style="width:100%">
          <input id="slider-r" type="range" min="0.2" max="2.0" step="0.2" value="1.0" />
          <span class="label-chip">r = <span id="label-r">1.0</span></span>
        </div>
      </div>

      <div class="group span-3">
        <h3>Velocità angolare ω</h3>
        <div class="row">
          <button id="btn-omega" class="btn omega">ω = 1</button>
        </div>
      </div>

      <div class="group span-3">
        <h3>Fase iniziale φ</h3>
        <div class="row">
          <button id="btn-phi" class="btn phi">φ = 0</button>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Parametri discreti ----------
    const omegaValues = [1,2,3,4,5];
    const phiValues = [
      0, Math.PI/4, Math.PI/2, 3*Math.PI/4,
      Math.PI, 5*Math.PI/4, 3*Math.PI/2, 7*Math.PI/4, 2*Math.PI
    ];
    const phiLabels = {
      [0]: "0",
      [Math.PI/4]: "π/4",
      [Math.PI/2]: "π/2",
      [3*Math.PI/4]: "3π/4",
      [Math.PI]: "π",
      [5*Math.PI/4]: "5π/4",
      [3*Math.PI/2]: "3π/2",
      [7*Math.PI/4]: "7π/4",
      [2*Math.PI]: "2π"
    };

    // ---------- Stato ----------
    let useSine = true;        // default: SENO
    let omegaIndex = 0;        // default: ω = 1
    let phiIndex = 0;          // default: φ = 0
    let r = 1.0;               // default: r = 1
    let paused = false;

    // Tempo (in secondi) e coda per grafico
    let t = 0;
    const windowSec = 10;      // ampiezza finestra visibile
    const lead = 1.0;          // margine "davanti al pallino"
    const dtTarget = 1/60;     // ~60 FPS
    let lastMillis = null;

    // Geometria canvas
    let W = 1000, H = 460;
    let leftPad = 20, topPad = 20, rightPad = 20, bottomPad = 20;

    // Pannelli
    let left = {x:0,y:0,w:0,h:0};
    let right = {x:0,y:0,w:0,h:0};

    // Dati del grafico (array di punti {t, y})
    const trail = [];

    // UI refs
    const elR = document.getElementById('slider-r');
    const elRLabel = document.getElementById('label-r');
    const btnToggle = document.getElementById('btn-toggle');
    const btnPause = document.getElementById('btn-pause');
    const btnReset = document.getElementById('btn-reset');
    const btnOmega = document.getElementById('btn-omega');
    const btnPhi = document.getElementById('btn-phi');

    // Setup p5 nel contenitore
    const holder = document.getElementById('canvas-holder');
    let sketch = (p) => {
      p.setup = () => {
        const cnv = p.createCanvas(W, H);
        cnv.parent(holder);
        layoutPanels();
        p.frameRate(60);
        p.textFont('system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif');
      };

      p.windowResized = () => {
        // Adatta larghezza al contenitore
        const bound = holder.getBoundingClientRect();
        W = Math.max(720, Math.min(1100, Math.floor(bound.width)));
        H = Math.floor(W * 0.46);
        p.resizeCanvas(W, H);
        layoutPanels();
      };

      p.draw = () => {
        p.background(255);

        // Delta-tempo fluido
        const now = p.millis() / 1000;
        if (lastMillis === null) lastMillis = now;
        let dt = now - lastMillis;
        lastMillis = now;
        // clamp per evitare salti quando il tab non è attivo
        dt = Math.min(dt, 0.05);

        if (!paused) t += dt;

        // Calcolo y(t) = r * f(ω t + φ)
        const omega = omegaValues[omegaIndex];
        const phi   = phiValues[phiIndex];
        const phase = omega * t + phi;
        const yt = r * (useSine ? Math.sin(phase) : Math.cos(phase));

        // Aggiorna trail (coda) e mantieni finestra temporale
        trail.push({t: t, y: yt});
        const tMin = Math.max(0, t - windowSec);
        while (trail.length && trail[0].t < tMin - 2) trail.shift();

        drawLeftPanel(p, omega, phi);
        drawRightPanel(p, t, yt);
      };
    };

    new p5(sketch);

    function layoutPanels(){
      const pad = 20;
      const midGap = 20;
      const usableW = W - leftPad - rightPad;
      const panelW = Math.floor((usableW - midGap) / 2);
      const panelH = H - topPad - bottomPad;

      left = {x:leftPad, y:topPad, w:panelW, h:panelH};
      right = {x:leftPad + panelW + midGap, y:topPad, w:panelW, h:panelH};
    }

    // Disegna assi con tacche essenziali
    function drawAxes(p, x, y, w, h){
      p.push();
      p.stroke(0); p.strokeWeight(1);
      // asse x (orizzontale al centro)
      p.line(x, y + h/2, x + w, y + h/2);
      // asse y (verticale al centro)
      p.line(x + w/2, y, x + w/2, y + h);
      p.pop();
    }

    // Pannello sinistro: cerchio e proiezione
    function drawLeftPanel(p, omega, phi){
      const cx = left.x + left.w * 0.5;
      const cy = left.y + left.h * 0.5;
      // scala r: facciamo che r=2 prenda ~85% del lato minore
      const maxSceneR = Math.min(left.w, left.h) * 0.38;
      const Rpx = r * (maxSceneR / 2); // r∈[0.2,2] → Rpx∈[0.1,1]*maxSceneR

      // cerchio
      p.push();
      p.noFill(); p.stroke(160); p.strokeWeight(1.5);
      p.circle(cx, cy, 2 * Rpx);
      p.pop();

      // punto rotante
      const angle = - omega * t - phi;
      const xRot = cx + Rpx * Math.cos(angle);
      const yRot = cy + Rpx * Math.sin(angle);

      // proiezione su x
      p.push();
      p.stroke(220,0,0); p.strokeWeight(1); p.drawingContext.setLineDash([6,4]);
      p.line(xRot, cy, xRot, yRot);
      p.pop();

      // punto blu (proiezione)
      p.push();
      p.fill(30,144,255); p.noStroke();
      p.circle(xRot, cy, 9);
      p.pop();

      // punto rosso sul cerchio
      p.push();
      p.fill(220,50,47); p.noStroke();
      p.circle(xRot, yRot, 11);
      p.pop();

      // assi
      drawAxes(p, left.x, left.y, left.w, left.h);
    }

    // Pannello destro: grafico scorrevole y(t)
    function drawRightPanel(p, tNow, yNow){
      const x0 = right.x, y0 = right.y, w = right.w, h = right.h;
      // mappa tempo → x con margine "lead"
      const tStart = Math.max(0, tNow - (windowSec - lead));
      const tEnd   = tStart + windowSec;

      // assi
      drawAxes(p, x0, y0, w, h);

      // griglia leggera
      p.push();
      p.stroke(235); p.strokeWeight(1);
      for (let i = -2; i <= 2; i++){
        const yy = p.map(i, -2, 2, y0 + h, y0);
        p.line(x0, yy, x0 + w, yy);
      }
      p.pop();

      // curva
      p.push();
      p.noFill(); p.stroke(0,114,178); p.strokeWeight(2);
      p.beginShape();
      for (let i = 0; i < trail.length; i++){
        const pt = trail[i];
        // salta i punti fuori finestra (con un po’ di coda)
        if (pt.t < tStart - 1 || pt.t > tEnd + 1) continue;
        const xx = p.map(pt.t, tStart, tEnd, x0, x0 + w);
        const yy = p.map(pt.y, -2, 2, y0 + h, y0);
        p.vertex(xx, yy);
      }
      p.endShape();
      p.pop();

      // pallino rosso corrente
      const xDot = p.map(tNow, tStart, tEnd, x0, x0 + w);
      const yDot = p.map(yNow, -2, 2, y0 + h, y0);
      p.push();
      p.fill(220,50,47); p.noStroke();
      p.circle(xDot, yDot, 12);
      p.pop();
    }

    // ---------- Interazione ----------
    elR.addEventListener('input', () => {
      r = parseFloat(elR.value);
      document.getElementById('label-r').textContent = r.toFixed(1);
      // aggiornamento fluido: pausa breve e riposiziona pallino
      softRefresh();
    });

    btnToggle.addEventListener('click', () => {
      useSine = !useSine;
      btnToggle.textContent = 'Funzione: ' + (useSine ? 'SENO' : 'COSENO');
      softRefresh();
    });

    btnPause.addEventListener('click', () => {
      paused = !paused;
      btnPause.textContent = paused ? 'Riprendi' : 'Blocca';
      // se in pausa, allinea il punto alla fase attuale immediatamente
      softRefresh(0);
    });

    btnReset.addEventListener('click', () => {
      t = 0; trail.length = 0;
      softRefresh(0);
    });

    btnOmega.addEventListener('click', () => {
      omegaIndex = (omegaIndex + 1) % omegaValues.length;
      btnOmega.textContent = `ω = ${omegaValues[omegaIndex]}`;
      softRefresh();
    });

    btnPhi.addEventListener('click', () => {
      phiIndex = (phiIndex + 1) % phiValues.length;
      const label = phiLabels[phiValues[phiIndex]];
      btnPhi.textContent = `φ = ${label}`;
      softRefresh(0);
    });

    // Piccolo “fermo” per aggiornamenti senza scatti quando cambio parametri
    function softRefresh(pauseMs = 120){
      const wasPaused = paused;
      paused = true;
      // riallinea pallino sul tempo corrente (o t=0 se appena resettato)
      const omega = omegaValues[omegaIndex];
      const phi = phiValues[phiIndex];
      const tt = t;
      const phase = omega * tt + phi;
      const y = r * (useSine ? Math.sin(phase) : Math.cos(phase));
      trail.push({t: tt, y: y});
      setTimeout(() => { paused = wasPaused; }, pauseMs);
    }

    // dimensiona canvas al primo layout
    window.dispatchEvent(new Event('resize'));
  </script>
</body>
</html>
