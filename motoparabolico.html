<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Moto parabolico — Cannone interattivo</title>
<script src="https://cdn.jsdelivr.net/npm/p5@1.9.2/lib/p5.min.js"></script>
<style>
  :root{
    --bg:#f3f7fb; --card:#fff; --muted:#6b7280; --accent:#0b84ff;
    --control:#eef2f6; --btn:#2d3748; --accent2:#ff8c42;
  }
  body { margin:0; font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:#111; }
  .wrap { max-width:1100px; margin:18px auto; padding:16px; }
  h1 { margin:0 0 6px; color:var(--accent); font-size:20px; }
  .sub { color:var(--muted); margin-bottom:12px; }
  #holder { width:100%; background:var(--card); border-radius:12px; box-shadow:0 8px 20px rgba(10,20,40,0.06); overflow:hidden; }
  .controls { display:flex; flex-wrap:wrap; gap:10px; align-items:center; padding:12px; }
  .ctrl { background:var(--control); padding:8px 10px; border-radius:8px; display:flex; gap:8px; align-items:center; }
  .label { font-weight:600; margin-right:6px; }
  input[type="range"] { width:200px; }
  .btn { background:var(--btn); color:white; border:0; padding:8px 12px; border-radius:8px; cursor:pointer; font-weight:700; }
  .btn.alt { background:var(--accent2); color:#120800; }
  .small { font-size:13px; color:var(--muted); margin-left:6px; }
  @media (max-width:820px){
    .controls { flex-direction:column; align-items:stretch; }
    input[type="range"]{ width:100%; }
  }
  .credits { margin-top:8px; color:var(--muted); font-size:13px; }
</style>
</head>
<body>
  <div class="wrap">
    <h1>Moto parabolico — Cannone interattivo</h1>
    <div class="sub">Scegli potenza e angolo, premi <strong>Spara</strong>. Vista destra segue il proiettile; sinistra mostra panorama con montagne e mare.</div>

    <div id="holder"></div>

    <div class="controls">
      <div class="ctrl">
        <span class="label">Potenza</span>
        <input id="power" type="range" min="10" max="120" step="1" value="60" />
        <span id="label-power" class="small">60</span>
      </div>

      <div class="ctrl">
        <span class="label">Angolo</span>
        <input id="angle" type="range" min="0" max="90" step="1" value="45" />
        <span id="label-angle" class="small">45°</span>
      </div>

      <div class="ctrl">
        <button id="btn-fire" class="btn">Spara</button>
        <button id="btn-pause" class="btn" style="margin-left:6px">Pausa</button>
        <button id="btn-reset" class="btn alt" style="margin-left:6px">Reset</button>
      </div>

      <div class="ctrl" style="margin-left:auto">
        <div class="small">g = 9.81 m/s² (scalato)</div>
      </div>
    </div>

    <div class="credits">Suggerimento: prova angoli diversi e confronta distanza massima teorica con quella reale (convento di resistenza dell'aria trascurata).</div>
  </div>

<script>
/* moto_parabolico.html
   - due pannelli: left = panorama (intera traiettoria), right = follow-cam
   - p5.js single-file
*/

// --- configurazione globale ---
let W = 1100, H = 520;
const holder = document.getElementById('holder');

// pannelli (calcolati in setup)
let leftPanel = {}, rightPanel = {};

// stato fisico (metrico ma scalato per visualizzazione)
const g = 9.81; // m/s^2
let scalePxPerMeter = 20; // px per metro, adattato in layout

// stato proiettile
let projectile = null; // {x,y,vx,vy, alive}
let trail = []; // array di {x,y}

// ambientazione
let groundY = 0; // in "world" meters, ground at y=0
let terrain = []; // mountains polyline in world coords (x,y meters)
let seaLevel = -1.0; // optional water level below ground (for visuals)

// camera follow settings
let followMargin = 30; // pixels on right

// UI refs
const inputPower = document.getElementById('power');
const inputAngle = document.getElementById('angle');
const labelPower = document.getElementById('label-power');
const labelAngle = document.getElementById('label-angle');
const btnFire = document.getElementById('btn-fire');
const btnPause = document.getElementById('btn-pause');
const btnReset = document.getElementById('btn-reset');

let paused = false;

// physics timestep smoothing
let lastMillis = null;

// p5 sketch
new p5(p => {
  p.setup = () => {
    // create canvas full width of holder
    const bounds = holder.getBoundingClientRect();
    W = Math.max(720, Math.min(1200, Math.floor(bounds.width)));
    H = Math.max(420, Math.floor(W * 0.45));
    const cnv = p.createCanvas(W, H);
    cnv.parent(holder);

    layoutPanels();
    generateTerrain();
    p.frameRate(60);
    lastMillis = p.millis();
  };

  p.windowResized = () => {
    const bounds = holder.getBoundingClientRect();
    W = Math.max(720, Math.min(1200, Math.floor(bounds.width)));
    H = Math.max(420, Math.floor(W * 0.45));
    p.resizeCanvas(W, H);
    layoutPanels();
  };

  p.draw = () => {
    // delta time in seconds, clamp
    const now = p.millis();
    let dt = (now - lastMillis) / 1000;
    lastMillis = now;
    dt = Math.min(dt, 0.05);

    if (!paused) {
      updatePhysics(dt);
    }

    // background & draw panels
    p.background(240);
    drawLeftPanel(p);
    drawRightPanel(p);
  };
});

// ----- layout / panels -----
function layoutPanels() {
  const gap = 12;
  const usableW = W - 2 * 12;
  const panelW = Math.floor((usableW - gap) / 2);
  const panelH = H - 24;
  leftPanel = {x:12, y:12, w:panelW, h:panelH};
  rightPanel = {x:12 + panelW + gap, y:12, w:panelW, h:panelH};

  // choose scale so that typical range ~ (panel width / scale)
  // want projectile travel ~ up to ~ (panelW / scale) meters
  scalePxPerMeter = Math.max(14, Math.min(30, Math.floor(leftPanel.w / 30))); // heuristic
}

// ----- generate terrain (mountains + ground) in world meters -----
function generateTerrain(){
  terrain = [];
  // create mountains as polyline in world coords (x in meters, y meters above ground)
  // we'll create a few gaussian-like hills
  const nHills = 4;
  const widthMeters = Math.max(80, Math.floor(leftPanel.w / scalePxPerMeter)); // visible width in meters
  const spacing = widthMeters / (nHills + 1);
  for(let i=0;i<nHills;i++){
    const cx = (i+1)*spacing + Math.random()*spacing*0.3;
    const amp = 6 + Math.random()*8;
    const spread = spacing*0.6 + Math.random()*spacing*0.3;
    terrain.push({cx, amp, spread});
  }
  // sea level is below ground (for visuals)
  seaLevel = -2.0;
}

// ----- utility: world -> screen for left (overview) -----
function worldToScreenLeft(xm, ym, p){
  // origin: leftPanel.x + margin, ground at panel center vertically
  const px = leftPanel.x + Math.round(xm * scalePxPerMeter) + 40; // 40 px left margin
  const pyGround = leftPanel.y + Math.round(leftPanel.h * 0.65); // ground baseline
  const py = pyGround - Math.round(ym * scalePxPerMeter);
  return {x:px, y:py, pyGround};
}

// ----- utility for right (follow) -----
function worldToScreenRight(xm, ym, p, camX){
  // camX is world x coordinate that maps to left of rightPanel
  const px = rightPanel.x + Math.round((xm - camX) * scalePxPerMeter) + 40;
  const pyGround = rightPanel.y + Math.round(rightPanel.h * 0.65);
  const py = pyGround - Math.round(ym * scalePxPerMeter);
  return {x:px, y:py, pyGround};
}

// ----- physics update -----
function updatePhysics(dt){
  // if projectile exists and alive: integrate
  if(projectile && projectile.alive){
    // simple ballistic: ax = 0 (no air resistance), ay = -g
    projectile.vy -= g * dt;
    projectile.x += projectile.vx * dt;
    projectile.y += projectile.vy * dt;

    // append trail
    trail.push({x:projectile.x, y:projectile.y});

    // check ground collision (ground y = 0)
    if(projectile.y <= 0){
      projectile.y = 0;
      projectile.alive = false;
    }

    // if projectile goes far outside leftPanel range, keep it
    // limit trail length
    if(trail.length > 5000) trail.shift();
  }
}

// ----- draw left panorama -----
function drawLeftPanel(p){
  const X = leftPanel.x, Y = leftPanel.y, Wp = leftPanel.w, Hp = leftPanel.h;
  p.push();
  // panel background
  p.noStroke(); p.fill(250); p.rect(X, Y, Wp, Hp, 8);

  // sky
  p.noStroke();
  const skyTop = Y;
  p.fill(135,206,235);
  p.rect(X, Y, Wp, Hp*0.6);

  // sea band at left portion (optional)
  p.fill(40,130,200,200);
  const seaH = Hp*0.15;
  p.rect(X, Y + Hp*0.6 + (Hp*0.25), Wp, seaH);

  // mountains: build silhouette polyline in screen coords
  const pts = [];
  const sampleCount = 120;
  for(let i=0;i<=sampleCount;i++){
    const xm = (i / sampleCount) * Math.max(120, Math.floor(Wp/scalePxPerMeter*1.2));
    // height from sum of gaussians
    let hm = 0;
    for(const hill of terrain){
      hm += hill.amp * Math.exp(-Math.pow((xm - hill.cx) / hill.spread, 2));
    }
    const scr = worldToScreenLeft(xm, hm, p);
    pts.push({x:scr.x, y:scr.y});
  }
  // draw mountains
  p.beginShape();
  p.fill(80,110,120); p.noStroke();
  // left top
  p.vertex(X, Y + Hp*0.65 + Hp*0.25 + 50);
  for(const pt of pts) p.vertex(pt.x, pt.y);
  p.vertex(X + Wp, Y + Hp*0.65 + Hp*0.25 + 50);
  p.endShape();

  // ground line
  const pyGround = leftPanel.y + Math.round(leftPanel.h * 0.65);
  p.stroke(80); p.strokeWeight(2);
  p.line(X, pyGround, X + Wp, pyGround);

  // draw cannon at origin (world x=0)
  const cannonScreen = worldToScreenLeft(0, 0, p);
  drawCannon(p, cannonScreen.x, cannonScreen.y, parseInt(inputAngle.value), false);

  // draw predicted trajectory (dotted) using kinematic formula ignoring ground clipping
  const pow = parseFloat(inputPower.value); // in arbitrary units -> m/s
  const angleDeg = parseFloat(inputAngle.value);
  const rad = angleDeg * Math.PI / 180;
  const vx0 = pow * Math.cos(rad);
  const vy0 = pow * Math.sin(rad);
  // predict up to Tth where y=0
  const discriminant = vy0*vy0 + 2*g*0; // y0=0
  let tFlight = 0;
  if (g>0) {
    tFlight = (vy0 + Math.sqrt(Math.max(0, vy0*vy0 + 2*g*0))) / g;
    // better compute root of y(t) = vy0 * t - 0.5*g*t^2 = 0 => t=0 and t=2*vy0/g
    tFlight = (2*vy0)/g;
  }
  // draw points
  p.stroke(0,0,0,80); p.strokeWeight(2); p.noFill();
  for(let tt=0; tt<tFlight; tt += Math.max(0.05, tFlight/80)){
    const xm = vx0*tt;
    const ym = vy0*tt - 0.5*g*tt*tt;
    const s = worldToScreenLeft(xm, ym, p);
    p.fill(0); p.noStroke();
    p.circle(s.x, s.y, 3);
  }

  // draw trail of actual launched projectile
  if(trail.length>0){
    p.noFill(); p.stroke(0,120,180); p.strokeWeight(2);
    p.beginShape();
    for(const pt of trail){
      const s = worldToScreenLeft(pt.x, pt.y, p);
      p.vertex(s.x, s.y);
    }
    p.endShape();
  }

  // draw projectile if exists
  if(projectile){
    const s = worldToScreenLeft(projectile.x, projectile.y, p);
    p.fill(220,40,40); p.noStroke();
    p.circle(s.x, s.y, 10);
  }

  // axis labels
  p.fill(40); p.noStroke(); p.textSize(13); p.text("Panorama (intera traiettoria)", X+8, Y+18);

  p.pop();
}

// draw cannon shape
function drawCannon(p, cx, cy, angleDeg, onRight){
  p.push();
  p.translate(cx, cy);
  // base
  p.fill(50); p.noStroke(); p.rect(-10, -10, 30, 18, 6);
  // barrel
  p.push();
  p.translate(5, -5);
  p.rotate(-angleDeg * Math.PI / 180); // negative because screen y down
  p.fill(60); p.rect(0, -6, 40, 12, 6);
  p.pop();
  p.pop();
}

// ----- draw right follow panel -----
function drawRightPanel(p){
  const X = rightPanel.x, Y = rightPanel.y, Wp = rightPanel.w, Hp = rightPanel.h;
  p.push();
  p.noStroke(); p.fill(250); p.rect(X, Y, Wp, Hp, 8);

  // sky gradient
  p.noStroke(); p.fill(150,205,240); p.rect(X, Y, Wp, Hp*0.5);

  // ground baseline
  const groundPx = Y + Math.round(Hp * 0.65);

  // decide camera: if projectile exists use its x as focus center else origin
  let camX = 0;
  if(projectile){
    camX = Math.max(0, projectile.x - 3); // keep projectile a bit from left
  }
  // draw mountains with offset according to cam
  // sample many points across world range from camX .. camX + viewMeters
  const viewMeters = Math.max(40, Math.floor(Wp/scalePxPerMeter*0.9));
  const leftWorld = camX;
  // mountain silhouette
  p.push();
  p.fill(90,120,135);
  p.noStroke();
  p.beginShape();
  p.vertex(X, Y + Hp*0.9);
  const sample = 80;
  for(let i=0;i<=sample;i++){
    const xm = leftWorld + (i/sample)*viewMeters;
    let hm = 0;
    for(const hill of terrain){
      hm += hill.amp * Math.exp(-Math.pow((xm - hill.cx)/hill.spread,2));
    }
    const s = worldToScreenRight(xm, hm, p, camX);
    p.vertex(s.x, s.y);
  }
  p.vertex(X + Wp, Y + Hp*0.9);
  p.endShape();
  p.pop();

  // ground line
  p.stroke(70); p.strokeWeight(2);
  p.line(X, groundPx, X + Wp, groundPx);

  // draw cannon relative to cam
  const cannonS = worldToScreenRight(0, 0, p, camX);
  drawCannon(p, cannonS.x, cannonS.y, parseInt(inputAngle.value), true);

  // draw trail
  if(trail.length>0){
    p.noFill(); p.stroke(0,120,180); p.strokeWeight(2);
    p.beginShape();
    for(const pt of trail){
      const s = worldToScreenRight(pt.x, pt.y, p, camX);
      p.vertex(s.x, s.y);
    }
    p.endShape();
  }

  // draw projectile (centered)
  if(projectile){
    const s = worldToScreenRight(projectile.x, projectile.y, p, camX);
    p.push();
    p.fill(220,40,40); p.noStroke();
    p.circle(s.x, s.y, 14);
    p.pop();
  }

  // axis / title
  p.fill(40); p.noStroke(); p.textSize(13); p.text("Vista ravvicinata (segue il proiettile)", X+8, Y+18);
  p.pop();
}

// ----- controls logic -----
inputPower.addEventListener('input', () => {
  labelPower.textContent = inputPower.value;
  // small visual feedback: if not launched, update predicted dots automatically via redraw
});
inputAngle.addEventListener('input', () => {
  labelAngle.textContent = inputAngle.value + "°";
});

btnReset.addEventListener('click', () => {
  projectile = null;
  trail = [];
  paused = false;
  lastMillis = performance.now();
});

btnPause.addEventListener('click', () => {
  paused = !paused;
  btnPause.textContent = paused ? "Riprendi" : "Pausa";
  // reset timing to avoid big dt jump
  lastMillis = performance.now();
});

btnFire.addEventListener('click', () => {
  if (projectile && projectile.alive) {
    // if already flying, ignore or restart
    return;
  }
  launchProjectile();
});

// ----- launch function -----
function launchProjectile(){
  // initial speed from power slider (map to m/s) — choose mapping so numbers feel natural
  const power = parseFloat(inputPower.value); // [10..120]
  // map: power px? we'll say 1 slider unit ≈ 0.6 m/s
  const v0 = power * 0.6; // m/s
  const angleDeg = parseFloat(inputAngle.value);
  const rad = angleDeg * Math.PI / 180;
  const vx = v0 * Math.cos(rad);
  const vy = v0 * Math.sin(rad);
  // create projectile at origin (x=0, y=0)
  projectile = {x:0, y:0, vx: vx, vy: vy, alive: true};
  trail = [{x:0,y:0}];
}

// ----- end of script -----
</script>
</body>
</html>
